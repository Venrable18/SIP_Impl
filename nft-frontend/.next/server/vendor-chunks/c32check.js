"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/c32check";
exports.ids = ["vendor-chunks/c32check"];
exports.modules = {

/***/ "(ssr)/./node_modules/c32check/lib/address.js":
/*!**********************************************!*\
  !*** ./node_modules/c32check/lib/address.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.c32ToB58 = exports.b58ToC32 = exports.c32addressDecode = exports.c32address = exports.versions = void 0;\nconst checksum_1 = __webpack_require__(/*! ./checksum */ \"(ssr)/./node_modules/c32check/lib/checksum.js\");\nconst base58check = __webpack_require__(/*! ./base58check */ \"(ssr)/./node_modules/c32check/lib/base58check.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\nexports.versions = {\n    mainnet: {\n        p2pkh: 22,\n        p2sh: 20, // 'M'\n    },\n    testnet: {\n        p2pkh: 26,\n        p2sh: 21, // 'N'\n    },\n};\n// address conversion : bitcoin to stacks\nconst ADDR_BITCOIN_TO_STACKS = {};\nADDR_BITCOIN_TO_STACKS[0] = exports.versions.mainnet.p2pkh;\nADDR_BITCOIN_TO_STACKS[5] = exports.versions.mainnet.p2sh;\nADDR_BITCOIN_TO_STACKS[111] = exports.versions.testnet.p2pkh;\nADDR_BITCOIN_TO_STACKS[196] = exports.versions.testnet.p2sh;\n// address conversion : stacks to bitcoin\nconst ADDR_STACKS_TO_BITCOIN = {};\nADDR_STACKS_TO_BITCOIN[exports.versions.mainnet.p2pkh] = 0;\nADDR_STACKS_TO_BITCOIN[exports.versions.mainnet.p2sh] = 5;\nADDR_STACKS_TO_BITCOIN[exports.versions.testnet.p2pkh] = 111;\nADDR_STACKS_TO_BITCOIN[exports.versions.testnet.p2sh] = 196;\n/**\n * Make a c32check address with the given version and hash160\n * The only difference between a c32check string and c32 address\n * is that the letter 'S' is pre-pended.\n * @param {number} version - the address version number\n * @param {string} hash160hex - the hash160 to encode (must be a hash160)\n * @returns {string} the address\n */\nfunction c32address(version, hash160hex) {\n    if (!hash160hex.match(/^[0-9a-fA-F]{40}$/)) {\n        throw new Error('Invalid argument: not a hash160 hex string');\n    }\n    const c32string = (0, checksum_1.c32checkEncode)(version, hash160hex);\n    return `S${c32string}`;\n}\nexports.c32address = c32address;\n/**\n * Decode a c32 address into its version and hash160\n * @param {string} c32addr - the c32check-encoded address\n * @returns {[number, string]} a tuple with the version and hash160\n */\nfunction c32addressDecode(c32addr) {\n    if (c32addr.length <= 5) {\n        throw new Error('Invalid c32 address: invalid length');\n    }\n    if (c32addr[0] != 'S') {\n        throw new Error('Invalid c32 address: must start with \"S\"');\n    }\n    return (0, checksum_1.c32checkDecode)(c32addr.slice(1));\n}\nexports.c32addressDecode = c32addressDecode;\n/*\n * Convert a base58check address to a c32check address.\n * Try to convert the version number if one is not given.\n * @param {string} b58check - the base58check encoded address\n * @param {number} version - the version number, if not inferred from the address\n * @returns {string} the c32 address with the given version number (or the\n *   semantically-equivalent c32 version number, if not given)\n */\nfunction b58ToC32(b58check, version = -1) {\n    const addrInfo = base58check.decode(b58check);\n    const hash160String = (0, utils_1.bytesToHex)(addrInfo.data);\n    const addrVersion = parseInt((0, utils_1.bytesToHex)(addrInfo.prefix), 16);\n    let stacksVersion;\n    if (version < 0) {\n        stacksVersion = addrVersion;\n        if (ADDR_BITCOIN_TO_STACKS[addrVersion] !== undefined) {\n            stacksVersion = ADDR_BITCOIN_TO_STACKS[addrVersion];\n        }\n    }\n    else {\n        stacksVersion = version;\n    }\n    return c32address(stacksVersion, hash160String);\n}\nexports.b58ToC32 = b58ToC32;\n/*\n * Convert a c32check address to a base58check address.\n * @param {string} c32string - the c32check address\n * @param {number} version - the version number, if not inferred from the address\n * @returns {string} the base58 address with the given version number (or the\n *    semantically-equivalent bitcoin version number, if not given)\n */\nfunction c32ToB58(c32string, version = -1) {\n    const addrInfo = c32addressDecode(c32string);\n    const stacksVersion = addrInfo[0];\n    const hash160String = addrInfo[1];\n    let bitcoinVersion;\n    if (version < 0) {\n        bitcoinVersion = stacksVersion;\n        if (ADDR_STACKS_TO_BITCOIN[stacksVersion] !== undefined) {\n            bitcoinVersion = ADDR_STACKS_TO_BITCOIN[stacksVersion];\n        }\n    }\n    else {\n        bitcoinVersion = version;\n    }\n    let prefix = bitcoinVersion.toString(16);\n    if (prefix.length === 1) {\n        prefix = `0${prefix}`;\n    }\n    return base58check.encode(hash160String, prefix);\n}\nexports.c32ToB58 = c32ToB58;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYzMyY2hlY2svbGliL2FkZHJlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsd0JBQXdCLEdBQUcsa0JBQWtCLEdBQUcsZ0JBQWdCO0FBQ3RHLG1CQUFtQixtQkFBTyxDQUFDLGlFQUFZO0FBQ3ZDLG9CQUFvQixtQkFBTyxDQUFDLHVFQUFlO0FBQzNDLGdCQUFnQixtQkFBTyxDQUFDLHdFQUFxQjtBQUM3QyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLHdDQUF3QyxHQUFHO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCIiwic291cmNlcyI6WyIvVXNlcnMvbWFjYm9vay9TSVBfSW1wbC9uZnQtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2MzMmNoZWNrL2xpYi9hZGRyZXNzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jMzJUb0I1OCA9IGV4cG9ydHMuYjU4VG9DMzIgPSBleHBvcnRzLmMzMmFkZHJlc3NEZWNvZGUgPSBleHBvcnRzLmMzMmFkZHJlc3MgPSBleHBvcnRzLnZlcnNpb25zID0gdm9pZCAwO1xuY29uc3QgY2hlY2tzdW1fMSA9IHJlcXVpcmUoXCIuL2NoZWNrc3VtXCIpO1xuY29uc3QgYmFzZTU4Y2hlY2sgPSByZXF1aXJlKFwiLi9iYXNlNThjaGVja1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiKTtcbmV4cG9ydHMudmVyc2lvbnMgPSB7XG4gICAgbWFpbm5ldDoge1xuICAgICAgICBwMnBraDogMjIsXG4gICAgICAgIHAyc2g6IDIwLCAvLyAnTSdcbiAgICB9LFxuICAgIHRlc3RuZXQ6IHtcbiAgICAgICAgcDJwa2g6IDI2LFxuICAgICAgICBwMnNoOiAyMSwgLy8gJ04nXG4gICAgfSxcbn07XG4vLyBhZGRyZXNzIGNvbnZlcnNpb24gOiBiaXRjb2luIHRvIHN0YWNrc1xuY29uc3QgQUREUl9CSVRDT0lOX1RPX1NUQUNLUyA9IHt9O1xuQUREUl9CSVRDT0lOX1RPX1NUQUNLU1swXSA9IGV4cG9ydHMudmVyc2lvbnMubWFpbm5ldC5wMnBraDtcbkFERFJfQklUQ09JTl9UT19TVEFDS1NbNV0gPSBleHBvcnRzLnZlcnNpb25zLm1haW5uZXQucDJzaDtcbkFERFJfQklUQ09JTl9UT19TVEFDS1NbMTExXSA9IGV4cG9ydHMudmVyc2lvbnMudGVzdG5ldC5wMnBraDtcbkFERFJfQklUQ09JTl9UT19TVEFDS1NbMTk2XSA9IGV4cG9ydHMudmVyc2lvbnMudGVzdG5ldC5wMnNoO1xuLy8gYWRkcmVzcyBjb252ZXJzaW9uIDogc3RhY2tzIHRvIGJpdGNvaW5cbmNvbnN0IEFERFJfU1RBQ0tTX1RPX0JJVENPSU4gPSB7fTtcbkFERFJfU1RBQ0tTX1RPX0JJVENPSU5bZXhwb3J0cy52ZXJzaW9ucy5tYWlubmV0LnAycGtoXSA9IDA7XG5BRERSX1NUQUNLU19UT19CSVRDT0lOW2V4cG9ydHMudmVyc2lvbnMubWFpbm5ldC5wMnNoXSA9IDU7XG5BRERSX1NUQUNLU19UT19CSVRDT0lOW2V4cG9ydHMudmVyc2lvbnMudGVzdG5ldC5wMnBraF0gPSAxMTE7XG5BRERSX1NUQUNLU19UT19CSVRDT0lOW2V4cG9ydHMudmVyc2lvbnMudGVzdG5ldC5wMnNoXSA9IDE5Njtcbi8qKlxuICogTWFrZSBhIGMzMmNoZWNrIGFkZHJlc3Mgd2l0aCB0aGUgZ2l2ZW4gdmVyc2lvbiBhbmQgaGFzaDE2MFxuICogVGhlIG9ubHkgZGlmZmVyZW5jZSBiZXR3ZWVuIGEgYzMyY2hlY2sgc3RyaW5nIGFuZCBjMzIgYWRkcmVzc1xuICogaXMgdGhhdCB0aGUgbGV0dGVyICdTJyBpcyBwcmUtcGVuZGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IHZlcnNpb24gLSB0aGUgYWRkcmVzcyB2ZXJzaW9uIG51bWJlclxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2gxNjBoZXggLSB0aGUgaGFzaDE2MCB0byBlbmNvZGUgKG11c3QgYmUgYSBoYXNoMTYwKVxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGFkZHJlc3NcbiAqL1xuZnVuY3Rpb24gYzMyYWRkcmVzcyh2ZXJzaW9uLCBoYXNoMTYwaGV4KSB7XG4gICAgaWYgKCFoYXNoMTYwaGV4Lm1hdGNoKC9eWzAtOWEtZkEtRl17NDB9JC8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudDogbm90IGEgaGFzaDE2MCBoZXggc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IGMzMnN0cmluZyA9ICgwLCBjaGVja3N1bV8xLmMzMmNoZWNrRW5jb2RlKSh2ZXJzaW9uLCBoYXNoMTYwaGV4KTtcbiAgICByZXR1cm4gYFMke2MzMnN0cmluZ31gO1xufVxuZXhwb3J0cy5jMzJhZGRyZXNzID0gYzMyYWRkcmVzcztcbi8qKlxuICogRGVjb2RlIGEgYzMyIGFkZHJlc3MgaW50byBpdHMgdmVyc2lvbiBhbmQgaGFzaDE2MFxuICogQHBhcmFtIHtzdHJpbmd9IGMzMmFkZHIgLSB0aGUgYzMyY2hlY2stZW5jb2RlZCBhZGRyZXNzXG4gKiBAcmV0dXJucyB7W251bWJlciwgc3RyaW5nXX0gYSB0dXBsZSB3aXRoIHRoZSB2ZXJzaW9uIGFuZCBoYXNoMTYwXG4gKi9cbmZ1bmN0aW9uIGMzMmFkZHJlc3NEZWNvZGUoYzMyYWRkcikge1xuICAgIGlmIChjMzJhZGRyLmxlbmd0aCA8PSA1KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjMzIgYWRkcmVzczogaW52YWxpZCBsZW5ndGgnKTtcbiAgICB9XG4gICAgaWYgKGMzMmFkZHJbMF0gIT0gJ1MnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjMzIgYWRkcmVzczogbXVzdCBzdGFydCB3aXRoIFwiU1wiJyk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgY2hlY2tzdW1fMS5jMzJjaGVja0RlY29kZSkoYzMyYWRkci5zbGljZSgxKSk7XG59XG5leHBvcnRzLmMzMmFkZHJlc3NEZWNvZGUgPSBjMzJhZGRyZXNzRGVjb2RlO1xuLypcbiAqIENvbnZlcnQgYSBiYXNlNThjaGVjayBhZGRyZXNzIHRvIGEgYzMyY2hlY2sgYWRkcmVzcy5cbiAqIFRyeSB0byBjb252ZXJ0IHRoZSB2ZXJzaW9uIG51bWJlciBpZiBvbmUgaXMgbm90IGdpdmVuLlxuICogQHBhcmFtIHtzdHJpbmd9IGI1OGNoZWNrIC0gdGhlIGJhc2U1OGNoZWNrIGVuY29kZWQgYWRkcmVzc1xuICogQHBhcmFtIHtudW1iZXJ9IHZlcnNpb24gLSB0aGUgdmVyc2lvbiBudW1iZXIsIGlmIG5vdCBpbmZlcnJlZCBmcm9tIHRoZSBhZGRyZXNzXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgYzMyIGFkZHJlc3Mgd2l0aCB0aGUgZ2l2ZW4gdmVyc2lvbiBudW1iZXIgKG9yIHRoZVxuICogICBzZW1hbnRpY2FsbHktZXF1aXZhbGVudCBjMzIgdmVyc2lvbiBudW1iZXIsIGlmIG5vdCBnaXZlbilcbiAqL1xuZnVuY3Rpb24gYjU4VG9DMzIoYjU4Y2hlY2ssIHZlcnNpb24gPSAtMSkge1xuICAgIGNvbnN0IGFkZHJJbmZvID0gYmFzZTU4Y2hlY2suZGVjb2RlKGI1OGNoZWNrKTtcbiAgICBjb25zdCBoYXNoMTYwU3RyaW5nID0gKDAsIHV0aWxzXzEuYnl0ZXNUb0hleCkoYWRkckluZm8uZGF0YSk7XG4gICAgY29uc3QgYWRkclZlcnNpb24gPSBwYXJzZUludCgoMCwgdXRpbHNfMS5ieXRlc1RvSGV4KShhZGRySW5mby5wcmVmaXgpLCAxNik7XG4gICAgbGV0IHN0YWNrc1ZlcnNpb247XG4gICAgaWYgKHZlcnNpb24gPCAwKSB7XG4gICAgICAgIHN0YWNrc1ZlcnNpb24gPSBhZGRyVmVyc2lvbjtcbiAgICAgICAgaWYgKEFERFJfQklUQ09JTl9UT19TVEFDS1NbYWRkclZlcnNpb25dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0YWNrc1ZlcnNpb24gPSBBRERSX0JJVENPSU5fVE9fU1RBQ0tTW2FkZHJWZXJzaW9uXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RhY2tzVmVyc2lvbiA9IHZlcnNpb247XG4gICAgfVxuICAgIHJldHVybiBjMzJhZGRyZXNzKHN0YWNrc1ZlcnNpb24sIGhhc2gxNjBTdHJpbmcpO1xufVxuZXhwb3J0cy5iNThUb0MzMiA9IGI1OFRvQzMyO1xuLypcbiAqIENvbnZlcnQgYSBjMzJjaGVjayBhZGRyZXNzIHRvIGEgYmFzZTU4Y2hlY2sgYWRkcmVzcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjMzJzdHJpbmcgLSB0aGUgYzMyY2hlY2sgYWRkcmVzc1xuICogQHBhcmFtIHtudW1iZXJ9IHZlcnNpb24gLSB0aGUgdmVyc2lvbiBudW1iZXIsIGlmIG5vdCBpbmZlcnJlZCBmcm9tIHRoZSBhZGRyZXNzXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgYmFzZTU4IGFkZHJlc3Mgd2l0aCB0aGUgZ2l2ZW4gdmVyc2lvbiBudW1iZXIgKG9yIHRoZVxuICogICAgc2VtYW50aWNhbGx5LWVxdWl2YWxlbnQgYml0Y29pbiB2ZXJzaW9uIG51bWJlciwgaWYgbm90IGdpdmVuKVxuICovXG5mdW5jdGlvbiBjMzJUb0I1OChjMzJzdHJpbmcsIHZlcnNpb24gPSAtMSkge1xuICAgIGNvbnN0IGFkZHJJbmZvID0gYzMyYWRkcmVzc0RlY29kZShjMzJzdHJpbmcpO1xuICAgIGNvbnN0IHN0YWNrc1ZlcnNpb24gPSBhZGRySW5mb1swXTtcbiAgICBjb25zdCBoYXNoMTYwU3RyaW5nID0gYWRkckluZm9bMV07XG4gICAgbGV0IGJpdGNvaW5WZXJzaW9uO1xuICAgIGlmICh2ZXJzaW9uIDwgMCkge1xuICAgICAgICBiaXRjb2luVmVyc2lvbiA9IHN0YWNrc1ZlcnNpb247XG4gICAgICAgIGlmIChBRERSX1NUQUNLU19UT19CSVRDT0lOW3N0YWNrc1ZlcnNpb25dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJpdGNvaW5WZXJzaW9uID0gQUREUl9TVEFDS1NfVE9fQklUQ09JTltzdGFja3NWZXJzaW9uXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYml0Y29pblZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIH1cbiAgICBsZXQgcHJlZml4ID0gYml0Y29pblZlcnNpb24udG9TdHJpbmcoMTYpO1xuICAgIGlmIChwcmVmaXgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHByZWZpeCA9IGAwJHtwcmVmaXh9YDtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2U1OGNoZWNrLmVuY29kZShoYXNoMTYwU3RyaW5nLCBwcmVmaXgpO1xufVxuZXhwb3J0cy5jMzJUb0I1OCA9IGMzMlRvQjU4O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/c32check/lib/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/c32check/lib/base58check.js":
/*!**************************************************!*\
  !*** ./node_modules/c32check/lib/base58check.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*\n * From https://github.com/wzbg/base58check\n * @Author: zyc\n * @Date:   2016-09-11 23:36:05\n */\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decode = exports.encode = void 0;\nconst sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/sha256.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\nconst basex = __webpack_require__(/*! base-x */ \"(ssr)/./node_modules/c32check/node_modules/base-x/src/index.js\");\nconst ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nfunction encode(data, prefix = '00') {\n    const dataBytes = typeof data === 'string' ? (0, utils_1.hexToBytes)(data) : data;\n    const prefixBytes = typeof prefix === 'string' ? (0, utils_1.hexToBytes)(prefix) : data;\n    if (!(dataBytes instanceof Uint8Array) || !(prefixBytes instanceof Uint8Array)) {\n        throw new TypeError('Argument must be of type Uint8Array or string');\n    }\n    const checksum = (0, sha256_1.sha256)((0, sha256_1.sha256)(new Uint8Array([...prefixBytes, ...dataBytes])));\n    return basex(ALPHABET).encode([...prefixBytes, ...dataBytes, ...checksum.slice(0, 4)]);\n}\nexports.encode = encode;\nfunction decode(string) {\n    const bytes = basex(ALPHABET).decode(string);\n    const prefixBytes = bytes.slice(0, 1);\n    const dataBytes = bytes.slice(1, -4);\n    // todo: for better performance replace spread with `concatBytes` method\n    const checksum = (0, sha256_1.sha256)((0, sha256_1.sha256)(new Uint8Array([...prefixBytes, ...dataBytes])));\n    bytes.slice(-4).forEach((check, index) => {\n        if (check !== checksum[index]) {\n            throw new Error('Invalid checksum');\n        }\n    });\n    return { prefix: prefixBytes, data: dataBytes };\n}\nexports.decode = decode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYzMyY2hlY2svbGliL2Jhc2U1OGNoZWNrLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsY0FBYztBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQywwRUFBc0I7QUFDL0MsZ0JBQWdCLG1CQUFPLENBQUMsd0VBQXFCO0FBQzdDLGNBQWMsbUJBQU8sQ0FBQyw4RUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhO0FBQ2I7QUFDQSxjQUFjIiwic291cmNlcyI6WyIvVXNlcnMvbWFjYm9vay9TSVBfSW1wbC9uZnQtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2MzMmNoZWNrL2xpYi9iYXNlNThjaGVjay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogRnJvbSBodHRwczovL2dpdGh1Yi5jb20vd3piZy9iYXNlNThjaGVja1xuICogQEF1dGhvcjogenljXG4gKiBARGF0ZTogICAyMDE2LTA5LTExIDIzOjM2OjA1XG4gKi9cbid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5lbmNvZGUgPSB2b2lkIDA7XG5jb25zdCBzaGEyNTZfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiKTtcbmNvbnN0IGJhc2V4ID0gcmVxdWlyZShcImJhc2UteFwiKTtcbmNvbnN0IEFMUEhBQkVUID0gJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonO1xuZnVuY3Rpb24gZW5jb2RlKGRhdGEsIHByZWZpeCA9ICcwMCcpIHtcbiAgICBjb25zdCBkYXRhQnl0ZXMgPSB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgPyAoMCwgdXRpbHNfMS5oZXhUb0J5dGVzKShkYXRhKSA6IGRhdGE7XG4gICAgY29uc3QgcHJlZml4Qnl0ZXMgPSB0eXBlb2YgcHJlZml4ID09PSAnc3RyaW5nJyA/ICgwLCB1dGlsc18xLmhleFRvQnl0ZXMpKHByZWZpeCkgOiBkYXRhO1xuICAgIGlmICghKGRhdGFCeXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHx8ICEocHJlZml4Qnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgVWludDhBcnJheSBvciBzdHJpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgY2hlY2tzdW0gPSAoMCwgc2hhMjU2XzEuc2hhMjU2KSgoMCwgc2hhMjU2XzEuc2hhMjU2KShuZXcgVWludDhBcnJheShbLi4ucHJlZml4Qnl0ZXMsIC4uLmRhdGFCeXRlc10pKSk7XG4gICAgcmV0dXJuIGJhc2V4KEFMUEhBQkVUKS5lbmNvZGUoWy4uLnByZWZpeEJ5dGVzLCAuLi5kYXRhQnl0ZXMsIC4uLmNoZWNrc3VtLnNsaWNlKDAsIDQpXSk7XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmZ1bmN0aW9uIGRlY29kZShzdHJpbmcpIHtcbiAgICBjb25zdCBieXRlcyA9IGJhc2V4KEFMUEhBQkVUKS5kZWNvZGUoc3RyaW5nKTtcbiAgICBjb25zdCBwcmVmaXhCeXRlcyA9IGJ5dGVzLnNsaWNlKDAsIDEpO1xuICAgIGNvbnN0IGRhdGFCeXRlcyA9IGJ5dGVzLnNsaWNlKDEsIC00KTtcbiAgICAvLyB0b2RvOiBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlIHJlcGxhY2Ugc3ByZWFkIHdpdGggYGNvbmNhdEJ5dGVzYCBtZXRob2RcbiAgICBjb25zdCBjaGVja3N1bSA9ICgwLCBzaGEyNTZfMS5zaGEyNTYpKCgwLCBzaGEyNTZfMS5zaGEyNTYpKG5ldyBVaW50OEFycmF5KFsuLi5wcmVmaXhCeXRlcywgLi4uZGF0YUJ5dGVzXSkpKTtcbiAgICBieXRlcy5zbGljZSgtNCkuZm9yRWFjaCgoY2hlY2ssIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChjaGVjayAhPT0gY2hlY2tzdW1baW5kZXhdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2hlY2tzdW0nKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7IHByZWZpeDogcHJlZml4Qnl0ZXMsIGRhdGE6IGRhdGFCeXRlcyB9O1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/c32check/lib/base58check.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/c32check/lib/checksum.js":
/*!***********************************************!*\
  !*** ./node_modules/c32check/lib/checksum.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.c32checkDecode = exports.c32checkEncode = void 0;\nconst sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/sha256.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\nconst encoding_1 = __webpack_require__(/*! ./encoding */ \"(ssr)/./node_modules/c32check/lib/encoding.js\");\n/**\n * Get the c32check checksum of a hex-encoded string\n * @param {string} dataHex - the hex string\n * @returns {string} the c32 checksum, as a bin-encoded string\n */\nfunction c32checksum(dataHex) {\n    const dataHash = (0, sha256_1.sha256)((0, sha256_1.sha256)((0, utils_1.hexToBytes)(dataHex)));\n    const checksum = (0, utils_1.bytesToHex)(dataHash.slice(0, 4));\n    return checksum;\n}\n/**\n * Encode a hex string as a c32check string.  This is a lot like how\n * base58check works in Bitcoin-land, but this algorithm uses the\n * z-base-32 alphabet instead of the base58 alphabet.  The algorithm\n * is as follows:\n * * calculate the c32checksum of version + data\n * * c32encode version + data + c32checksum\n * @param {number} version - the version string (between 0 and 31)\n * @param {string} data - the data to encode\n * @returns {string} the c32check representation\n */\nfunction c32checkEncode(version, data) {\n    if (version < 0 || version >= 32) {\n        throw new Error('Invalid version (must be between 0 and 31)');\n    }\n    if (!data.match(/^[0-9a-fA-F]*$/)) {\n        throw new Error('Invalid data (not a hex string)');\n    }\n    data = data.toLowerCase();\n    if (data.length % 2 !== 0) {\n        data = `0${data}`;\n    }\n    let versionHex = version.toString(16);\n    if (versionHex.length === 1) {\n        versionHex = `0${versionHex}`;\n    }\n    const checksumHex = c32checksum(`${versionHex}${data}`);\n    const c32str = (0, encoding_1.c32encode)(`${data}${checksumHex}`);\n    return `${encoding_1.c32[version]}${c32str}`;\n}\nexports.c32checkEncode = c32checkEncode;\n/*\n * Decode a c32check string back into its version and data payload.  This is\n * a lot like how base58check works in Bitcoin-land, but this algorithm uses\n * the z-base-32 alphabet instead of the base58 alphabet.  The algorithm\n * is as follows:\n * * extract the version, data, and checksum\n * * verify the checksum matches c32checksum(version + data)\n * * return data\n * @param {string} c32data - the c32check-encoded string\n * @returns {array} [version (number), data (string)].  The returned data\n * will be a hex string.  Throws an exception if the checksum does not match.\n */\nfunction c32checkDecode(c32data) {\n    c32data = (0, encoding_1.c32normalize)(c32data);\n    const dataHex = (0, encoding_1.c32decode)(c32data.slice(1));\n    const versionChar = c32data[0];\n    const version = encoding_1.c32.indexOf(versionChar);\n    const checksum = dataHex.slice(-8);\n    let versionHex = version.toString(16);\n    if (versionHex.length === 1) {\n        versionHex = `0${versionHex}`;\n    }\n    if (c32checksum(`${versionHex}${dataHex.substring(0, dataHex.length - 8)}`) !== checksum) {\n        throw new Error('Invalid c32check string: checksum mismatch');\n    }\n    return [version, dataHex.substring(0, dataHex.length - 8)];\n}\nexports.c32checkDecode = c32checkDecode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYzMyY2hlY2svbGliL2NoZWNrc3VtLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLHNCQUFzQjtBQUMvQyxpQkFBaUIsbUJBQU8sQ0FBQywwRUFBc0I7QUFDL0MsZ0JBQWdCLG1CQUFPLENBQUMsd0VBQXFCO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLGlFQUFZO0FBQ3ZDO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsS0FBSztBQUN4QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsV0FBVztBQUNwQztBQUNBLHVDQUF1QyxXQUFXLEVBQUUsS0FBSztBQUN6RCxnREFBZ0QsS0FBSyxFQUFFLFlBQVk7QUFDbkUsY0FBYyx3QkFBd0IsRUFBRSxPQUFPO0FBQy9DO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFdBQVc7QUFDcEM7QUFDQSx1QkFBdUIsV0FBVyxFQUFFLHlDQUF5QztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiIsInNvdXJjZXMiOlsiL1VzZXJzL21hY2Jvb2svU0lQX0ltcGwvbmZ0LWZyb250ZW5kL25vZGVfbW9kdWxlcy9jMzJjaGVjay9saWIvY2hlY2tzdW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmMzMmNoZWNrRGVjb2RlID0gZXhwb3J0cy5jMzJjaGVja0VuY29kZSA9IHZvaWQgMDtcbmNvbnN0IHNoYTI1Nl8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCIpO1xuY29uc3QgZW5jb2RpbmdfMSA9IHJlcXVpcmUoXCIuL2VuY29kaW5nXCIpO1xuLyoqXG4gKiBHZXQgdGhlIGMzMmNoZWNrIGNoZWNrc3VtIG9mIGEgaGV4LWVuY29kZWQgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YUhleCAtIHRoZSBoZXggc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgYzMyIGNoZWNrc3VtLCBhcyBhIGJpbi1lbmNvZGVkIHN0cmluZ1xuICovXG5mdW5jdGlvbiBjMzJjaGVja3N1bShkYXRhSGV4KSB7XG4gICAgY29uc3QgZGF0YUhhc2ggPSAoMCwgc2hhMjU2XzEuc2hhMjU2KSgoMCwgc2hhMjU2XzEuc2hhMjU2KSgoMCwgdXRpbHNfMS5oZXhUb0J5dGVzKShkYXRhSGV4KSkpO1xuICAgIGNvbnN0IGNoZWNrc3VtID0gKDAsIHV0aWxzXzEuYnl0ZXNUb0hleCkoZGF0YUhhc2guc2xpY2UoMCwgNCkpO1xuICAgIHJldHVybiBjaGVja3N1bTtcbn1cbi8qKlxuICogRW5jb2RlIGEgaGV4IHN0cmluZyBhcyBhIGMzMmNoZWNrIHN0cmluZy4gIFRoaXMgaXMgYSBsb3QgbGlrZSBob3dcbiAqIGJhc2U1OGNoZWNrIHdvcmtzIGluIEJpdGNvaW4tbGFuZCwgYnV0IHRoaXMgYWxnb3JpdGhtIHVzZXMgdGhlXG4gKiB6LWJhc2UtMzIgYWxwaGFiZXQgaW5zdGVhZCBvZiB0aGUgYmFzZTU4IGFscGhhYmV0LiAgVGhlIGFsZ29yaXRobVxuICogaXMgYXMgZm9sbG93czpcbiAqICogY2FsY3VsYXRlIHRoZSBjMzJjaGVja3N1bSBvZiB2ZXJzaW9uICsgZGF0YVxuICogKiBjMzJlbmNvZGUgdmVyc2lvbiArIGRhdGEgKyBjMzJjaGVja3N1bVxuICogQHBhcmFtIHtudW1iZXJ9IHZlcnNpb24gLSB0aGUgdmVyc2lvbiBzdHJpbmcgKGJldHdlZW4gMCBhbmQgMzEpXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YSAtIHRoZSBkYXRhIHRvIGVuY29kZVxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGMzMmNoZWNrIHJlcHJlc2VudGF0aW9uXG4gKi9cbmZ1bmN0aW9uIGMzMmNoZWNrRW5jb2RlKHZlcnNpb24sIGRhdGEpIHtcbiAgICBpZiAodmVyc2lvbiA8IDAgfHwgdmVyc2lvbiA+PSAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmVyc2lvbiAobXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDMxKScpO1xuICAgIH1cbiAgICBpZiAoIWRhdGEubWF0Y2goL15bMC05YS1mQS1GXSokLykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRhdGEgKG5vdCBhIGhleCBzdHJpbmcpJyk7XG4gICAgfVxuICAgIGRhdGEgPSBkYXRhLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGRhdGEubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICBkYXRhID0gYDAke2RhdGF9YDtcbiAgICB9XG4gICAgbGV0IHZlcnNpb25IZXggPSB2ZXJzaW9uLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAodmVyc2lvbkhleC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdmVyc2lvbkhleCA9IGAwJHt2ZXJzaW9uSGV4fWA7XG4gICAgfVxuICAgIGNvbnN0IGNoZWNrc3VtSGV4ID0gYzMyY2hlY2tzdW0oYCR7dmVyc2lvbkhleH0ke2RhdGF9YCk7XG4gICAgY29uc3QgYzMyc3RyID0gKDAsIGVuY29kaW5nXzEuYzMyZW5jb2RlKShgJHtkYXRhfSR7Y2hlY2tzdW1IZXh9YCk7XG4gICAgcmV0dXJuIGAke2VuY29kaW5nXzEuYzMyW3ZlcnNpb25dfSR7YzMyc3RyfWA7XG59XG5leHBvcnRzLmMzMmNoZWNrRW5jb2RlID0gYzMyY2hlY2tFbmNvZGU7XG4vKlxuICogRGVjb2RlIGEgYzMyY2hlY2sgc3RyaW5nIGJhY2sgaW50byBpdHMgdmVyc2lvbiBhbmQgZGF0YSBwYXlsb2FkLiAgVGhpcyBpc1xuICogYSBsb3QgbGlrZSBob3cgYmFzZTU4Y2hlY2sgd29ya3MgaW4gQml0Y29pbi1sYW5kLCBidXQgdGhpcyBhbGdvcml0aG0gdXNlc1xuICogdGhlIHotYmFzZS0zMiBhbHBoYWJldCBpbnN0ZWFkIG9mIHRoZSBiYXNlNTggYWxwaGFiZXQuICBUaGUgYWxnb3JpdGhtXG4gKiBpcyBhcyBmb2xsb3dzOlxuICogKiBleHRyYWN0IHRoZSB2ZXJzaW9uLCBkYXRhLCBhbmQgY2hlY2tzdW1cbiAqICogdmVyaWZ5IHRoZSBjaGVja3N1bSBtYXRjaGVzIGMzMmNoZWNrc3VtKHZlcnNpb24gKyBkYXRhKVxuICogKiByZXR1cm4gZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IGMzMmRhdGEgLSB0aGUgYzMyY2hlY2stZW5jb2RlZCBzdHJpbmdcbiAqIEByZXR1cm5zIHthcnJheX0gW3ZlcnNpb24gKG51bWJlciksIGRhdGEgKHN0cmluZyldLiAgVGhlIHJldHVybmVkIGRhdGFcbiAqIHdpbGwgYmUgYSBoZXggc3RyaW5nLiAgVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0aGUgY2hlY2tzdW0gZG9lcyBub3QgbWF0Y2guXG4gKi9cbmZ1bmN0aW9uIGMzMmNoZWNrRGVjb2RlKGMzMmRhdGEpIHtcbiAgICBjMzJkYXRhID0gKDAsIGVuY29kaW5nXzEuYzMybm9ybWFsaXplKShjMzJkYXRhKTtcbiAgICBjb25zdCBkYXRhSGV4ID0gKDAsIGVuY29kaW5nXzEuYzMyZGVjb2RlKShjMzJkYXRhLnNsaWNlKDEpKTtcbiAgICBjb25zdCB2ZXJzaW9uQ2hhciA9IGMzMmRhdGFbMF07XG4gICAgY29uc3QgdmVyc2lvbiA9IGVuY29kaW5nXzEuYzMyLmluZGV4T2YodmVyc2lvbkNoYXIpO1xuICAgIGNvbnN0IGNoZWNrc3VtID0gZGF0YUhleC5zbGljZSgtOCk7XG4gICAgbGV0IHZlcnNpb25IZXggPSB2ZXJzaW9uLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAodmVyc2lvbkhleC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdmVyc2lvbkhleCA9IGAwJHt2ZXJzaW9uSGV4fWA7XG4gICAgfVxuICAgIGlmIChjMzJjaGVja3N1bShgJHt2ZXJzaW9uSGV4fSR7ZGF0YUhleC5zdWJzdHJpbmcoMCwgZGF0YUhleC5sZW5ndGggLSA4KX1gKSAhPT0gY2hlY2tzdW0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGMzMmNoZWNrIHN0cmluZzogY2hlY2tzdW0gbWlzbWF0Y2gnKTtcbiAgICB9XG4gICAgcmV0dXJuIFt2ZXJzaW9uLCBkYXRhSGV4LnN1YnN0cmluZygwLCBkYXRhSGV4Lmxlbmd0aCAtIDgpXTtcbn1cbmV4cG9ydHMuYzMyY2hlY2tEZWNvZGUgPSBjMzJjaGVja0RlY29kZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/c32check/lib/checksum.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/c32check/lib/encoding.js":
/*!***********************************************!*\
  !*** ./node_modules/c32check/lib/encoding.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.c32decode = exports.c32normalize = exports.c32encode = exports.c32 = void 0;\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\nexports.c32 = '0123456789ABCDEFGHJKMNPQRSTVWXYZ';\nconst hex = '0123456789abcdef';\n/**\n * Encode a hex string as a c32 string.  Note that the hex string is assumed\n * to be big-endian (and the resulting c32 string will be as well).\n * @param {string} inputHex - the input to encode\n * @param {number} minLength - the minimum length of the c32 string\n * @returns {string} the c32check-encoded representation of the data, as a string\n */\nfunction c32encode(inputHex, minLength) {\n    // must be hex\n    if (!inputHex.match(/^[0-9a-fA-F]*$/)) {\n        throw new Error('Not a hex-encoded string');\n    }\n    if (inputHex.length % 2 !== 0) {\n        inputHex = `0${inputHex}`;\n    }\n    inputHex = inputHex.toLowerCase();\n    let res = [];\n    let carry = 0;\n    for (let i = inputHex.length - 1; i >= 0; i--) {\n        if (carry < 4) {\n            const currentCode = hex.indexOf(inputHex[i]) >> carry;\n            let nextCode = 0;\n            if (i !== 0) {\n                nextCode = hex.indexOf(inputHex[i - 1]);\n            }\n            // carry = 0, nextBits is 1, carry = 1, nextBits is 2\n            const nextBits = 1 + carry;\n            const nextLowBits = nextCode % (1 << nextBits) << (5 - nextBits);\n            const curC32Digit = exports.c32[currentCode + nextLowBits];\n            carry = nextBits;\n            res.unshift(curC32Digit);\n        }\n        else {\n            carry = 0;\n        }\n    }\n    let C32leadingZeros = 0;\n    for (let i = 0; i < res.length; i++) {\n        if (res[i] !== '0') {\n            break;\n        }\n        else {\n            C32leadingZeros++;\n        }\n    }\n    res = res.slice(C32leadingZeros);\n    const zeroPrefix = new TextDecoder().decode((0, utils_1.hexToBytes)(inputHex)).match(/^\\u0000*/);\n    const numLeadingZeroBytesInHex = zeroPrefix ? zeroPrefix[0].length : 0;\n    for (let i = 0; i < numLeadingZeroBytesInHex; i++) {\n        res.unshift(exports.c32[0]);\n    }\n    if (minLength) {\n        const count = minLength - res.length;\n        for (let i = 0; i < count; i++) {\n            res.unshift(exports.c32[0]);\n        }\n    }\n    return res.join('');\n}\nexports.c32encode = c32encode;\n/*\n * Normalize a c32 string\n * @param {string} c32input - the c32-encoded input string\n * @returns {string} the canonical representation of the c32 input string\n */\nfunction c32normalize(c32input) {\n    // must be upper-case\n    // replace all O's with 0's\n    // replace all I's and L's with 1's\n    return c32input.toUpperCase().replace(/O/g, '0').replace(/L|I/g, '1');\n}\nexports.c32normalize = c32normalize;\n/*\n * Decode a c32 string back into a hex string.  Note that the c32 input\n * string is assumed to be big-endian (and the resulting hex string will\n * be as well).\n * @param {string} c32input - the c32-encoded input to decode\n * @param {number} minLength - the minimum length of the output hex string (in bytes)\n * @returns {string} the hex-encoded representation of the data, as a string\n */\nfunction c32decode(c32input, minLength) {\n    c32input = c32normalize(c32input);\n    // must result in a c32 string\n    if (!c32input.match(`^[${exports.c32}]*$`)) {\n        throw new Error('Not a c32-encoded string');\n    }\n    const zeroPrefix = c32input.match(`^${exports.c32[0]}*`);\n    const numLeadingZeroBytes = zeroPrefix ? zeroPrefix[0].length : 0;\n    let res = [];\n    let carry = 0;\n    let carryBits = 0;\n    for (let i = c32input.length - 1; i >= 0; i--) {\n        if (carryBits === 4) {\n            res.unshift(hex[carry]);\n            carryBits = 0;\n            carry = 0;\n        }\n        const currentCode = exports.c32.indexOf(c32input[i]) << carryBits;\n        const currentValue = currentCode + carry;\n        const currentHexDigit = hex[currentValue % 16];\n        carryBits += 1;\n        carry = currentValue >> 4;\n        if (carry > 1 << carryBits) {\n            throw new Error('Panic error in decoding.');\n        }\n        res.unshift(currentHexDigit);\n    }\n    // one last carry\n    res.unshift(hex[carry]);\n    if (res.length % 2 === 1) {\n        res.unshift('0');\n    }\n    let hexLeadingZeros = 0;\n    for (let i = 0; i < res.length; i++) {\n        if (res[i] !== '0') {\n            break;\n        }\n        else {\n            hexLeadingZeros++;\n        }\n    }\n    res = res.slice(hexLeadingZeros - (hexLeadingZeros % 2));\n    let hexStr = res.join('');\n    for (let i = 0; i < numLeadingZeroBytes; i++) {\n        hexStr = `00${hexStr}`;\n    }\n    if (minLength) {\n        const count = minLength * 2 - hexStr.length;\n        for (let i = 0; i < count; i += 2) {\n            hexStr = `00${hexStr}`;\n        }\n    }\n    return hexStr;\n}\nexports.c32decode = c32decode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYzMyY2hlY2svbGliL2VuY29kaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLG9CQUFvQixHQUFHLGlCQUFpQixHQUFHLFdBQVc7QUFDMUUsZ0JBQWdCLG1CQUFPLENBQUMsd0VBQXFCO0FBQzdDLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhCQUE4QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixZQUFZO0FBQ3pDO0FBQ0E7QUFDQSwwQ0FBMEMsZUFBZTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QyxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQywwQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiIsInNvdXJjZXMiOlsiL1VzZXJzL21hY2Jvb2svU0lQX0ltcGwvbmZ0LWZyb250ZW5kL25vZGVfbW9kdWxlcy9jMzJjaGVjay9saWIvZW5jb2RpbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmMzMmRlY29kZSA9IGV4cG9ydHMuYzMybm9ybWFsaXplID0gZXhwb3J0cy5jMzJlbmNvZGUgPSBleHBvcnRzLmMzMiA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiKTtcbmV4cG9ydHMuYzMyID0gJzAxMjM0NTY3ODlBQkNERUZHSEpLTU5QUVJTVFZXWFlaJztcbmNvbnN0IGhleCA9ICcwMTIzNDU2Nzg5YWJjZGVmJztcbi8qKlxuICogRW5jb2RlIGEgaGV4IHN0cmluZyBhcyBhIGMzMiBzdHJpbmcuICBOb3RlIHRoYXQgdGhlIGhleCBzdHJpbmcgaXMgYXNzdW1lZFxuICogdG8gYmUgYmlnLWVuZGlhbiAoYW5kIHRoZSByZXN1bHRpbmcgYzMyIHN0cmluZyB3aWxsIGJlIGFzIHdlbGwpLlxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0SGV4IC0gdGhlIGlucHV0IHRvIGVuY29kZVxuICogQHBhcmFtIHtudW1iZXJ9IG1pbkxlbmd0aCAtIHRoZSBtaW5pbXVtIGxlbmd0aCBvZiB0aGUgYzMyIHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ30gdGhlIGMzMmNoZWNrLWVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGRhdGEsIGFzIGEgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGMzMmVuY29kZShpbnB1dEhleCwgbWluTGVuZ3RoKSB7XG4gICAgLy8gbXVzdCBiZSBoZXhcbiAgICBpZiAoIWlucHV0SGV4Lm1hdGNoKC9eWzAtOWEtZkEtRl0qJC8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgaGV4LWVuY29kZWQgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmIChpbnB1dEhleC5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIGlucHV0SGV4ID0gYDAke2lucHV0SGV4fWA7XG4gICAgfVxuICAgIGlucHV0SGV4ID0gaW5wdXRIZXgudG9Mb3dlckNhc2UoKTtcbiAgICBsZXQgcmVzID0gW107XG4gICAgbGV0IGNhcnJ5ID0gMDtcbiAgICBmb3IgKGxldCBpID0gaW5wdXRIZXgubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKGNhcnJ5IDwgNCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudENvZGUgPSBoZXguaW5kZXhPZihpbnB1dEhleFtpXSkgPj4gY2Fycnk7XG4gICAgICAgICAgICBsZXQgbmV4dENvZGUgPSAwO1xuICAgICAgICAgICAgaWYgKGkgIT09IDApIHtcbiAgICAgICAgICAgICAgICBuZXh0Q29kZSA9IGhleC5pbmRleE9mKGlucHV0SGV4W2kgLSAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjYXJyeSA9IDAsIG5leHRCaXRzIGlzIDEsIGNhcnJ5ID0gMSwgbmV4dEJpdHMgaXMgMlxuICAgICAgICAgICAgY29uc3QgbmV4dEJpdHMgPSAxICsgY2Fycnk7XG4gICAgICAgICAgICBjb25zdCBuZXh0TG93Qml0cyA9IG5leHRDb2RlICUgKDEgPDwgbmV4dEJpdHMpIDw8ICg1IC0gbmV4dEJpdHMpO1xuICAgICAgICAgICAgY29uc3QgY3VyQzMyRGlnaXQgPSBleHBvcnRzLmMzMltjdXJyZW50Q29kZSArIG5leHRMb3dCaXRzXTtcbiAgICAgICAgICAgIGNhcnJ5ID0gbmV4dEJpdHM7XG4gICAgICAgICAgICByZXMudW5zaGlmdChjdXJDMzJEaWdpdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYXJyeSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IEMzMmxlYWRpbmdaZXJvcyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJlc1tpXSAhPT0gJzAnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIEMzMmxlYWRpbmdaZXJvcysrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcyA9IHJlcy5zbGljZShDMzJsZWFkaW5nWmVyb3MpO1xuICAgIGNvbnN0IHplcm9QcmVmaXggPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoKDAsIHV0aWxzXzEuaGV4VG9CeXRlcykoaW5wdXRIZXgpKS5tYXRjaCgvXlxcdTAwMDAqLyk7XG4gICAgY29uc3QgbnVtTGVhZGluZ1plcm9CeXRlc0luSGV4ID0gemVyb1ByZWZpeCA/IHplcm9QcmVmaXhbMF0ubGVuZ3RoIDogMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUxlYWRpbmdaZXJvQnl0ZXNJbkhleDsgaSsrKSB7XG4gICAgICAgIHJlcy51bnNoaWZ0KGV4cG9ydHMuYzMyWzBdKTtcbiAgICB9XG4gICAgaWYgKG1pbkxlbmd0aCkge1xuICAgICAgICBjb25zdCBjb3VudCA9IG1pbkxlbmd0aCAtIHJlcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgcmVzLnVuc2hpZnQoZXhwb3J0cy5jMzJbMF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXMuam9pbignJyk7XG59XG5leHBvcnRzLmMzMmVuY29kZSA9IGMzMmVuY29kZTtcbi8qXG4gKiBOb3JtYWxpemUgYSBjMzIgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gYzMyaW5wdXQgLSB0aGUgYzMyLWVuY29kZWQgaW5wdXQgc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgY2Fub25pY2FsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjMzIgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGMzMm5vcm1hbGl6ZShjMzJpbnB1dCkge1xuICAgIC8vIG11c3QgYmUgdXBwZXItY2FzZVxuICAgIC8vIHJlcGxhY2UgYWxsIE8ncyB3aXRoIDAnc1xuICAgIC8vIHJlcGxhY2UgYWxsIEkncyBhbmQgTCdzIHdpdGggMSdzXG4gICAgcmV0dXJuIGMzMmlucHV0LnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvTy9nLCAnMCcpLnJlcGxhY2UoL0x8SS9nLCAnMScpO1xufVxuZXhwb3J0cy5jMzJub3JtYWxpemUgPSBjMzJub3JtYWxpemU7XG4vKlxuICogRGVjb2RlIGEgYzMyIHN0cmluZyBiYWNrIGludG8gYSBoZXggc3RyaW5nLiAgTm90ZSB0aGF0IHRoZSBjMzIgaW5wdXRcbiAqIHN0cmluZyBpcyBhc3N1bWVkIHRvIGJlIGJpZy1lbmRpYW4gKGFuZCB0aGUgcmVzdWx0aW5nIGhleCBzdHJpbmcgd2lsbFxuICogYmUgYXMgd2VsbCkuXG4gKiBAcGFyYW0ge3N0cmluZ30gYzMyaW5wdXQgLSB0aGUgYzMyLWVuY29kZWQgaW5wdXQgdG8gZGVjb2RlXG4gKiBAcGFyYW0ge251bWJlcn0gbWluTGVuZ3RoIC0gdGhlIG1pbmltdW0gbGVuZ3RoIG9mIHRoZSBvdXRwdXQgaGV4IHN0cmluZyAoaW4gYnl0ZXMpXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgaGV4LWVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGRhdGEsIGFzIGEgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGMzMmRlY29kZShjMzJpbnB1dCwgbWluTGVuZ3RoKSB7XG4gICAgYzMyaW5wdXQgPSBjMzJub3JtYWxpemUoYzMyaW5wdXQpO1xuICAgIC8vIG11c3QgcmVzdWx0IGluIGEgYzMyIHN0cmluZ1xuICAgIGlmICghYzMyaW5wdXQubWF0Y2goYF5bJHtleHBvcnRzLmMzMn1dKiRgKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIGMzMi1lbmNvZGVkIHN0cmluZycpO1xuICAgIH1cbiAgICBjb25zdCB6ZXJvUHJlZml4ID0gYzMyaW5wdXQubWF0Y2goYF4ke2V4cG9ydHMuYzMyWzBdfSpgKTtcbiAgICBjb25zdCBudW1MZWFkaW5nWmVyb0J5dGVzID0gemVyb1ByZWZpeCA/IHplcm9QcmVmaXhbMF0ubGVuZ3RoIDogMDtcbiAgICBsZXQgcmVzID0gW107XG4gICAgbGV0IGNhcnJ5ID0gMDtcbiAgICBsZXQgY2FycnlCaXRzID0gMDtcbiAgICBmb3IgKGxldCBpID0gYzMyaW5wdXQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKGNhcnJ5Qml0cyA9PT0gNCkge1xuICAgICAgICAgICAgcmVzLnVuc2hpZnQoaGV4W2NhcnJ5XSk7XG4gICAgICAgICAgICBjYXJyeUJpdHMgPSAwO1xuICAgICAgICAgICAgY2FycnkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDb2RlID0gZXhwb3J0cy5jMzIuaW5kZXhPZihjMzJpbnB1dFtpXSkgPDwgY2FycnlCaXRzO1xuICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBjdXJyZW50Q29kZSArIGNhcnJ5O1xuICAgICAgICBjb25zdCBjdXJyZW50SGV4RGlnaXQgPSBoZXhbY3VycmVudFZhbHVlICUgMTZdO1xuICAgICAgICBjYXJyeUJpdHMgKz0gMTtcbiAgICAgICAgY2FycnkgPSBjdXJyZW50VmFsdWUgPj4gNDtcbiAgICAgICAgaWYgKGNhcnJ5ID4gMSA8PCBjYXJyeUJpdHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGFuaWMgZXJyb3IgaW4gZGVjb2RpbmcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnVuc2hpZnQoY3VycmVudEhleERpZ2l0KTtcbiAgICB9XG4gICAgLy8gb25lIGxhc3QgY2FycnlcbiAgICByZXMudW5zaGlmdChoZXhbY2FycnldKTtcbiAgICBpZiAocmVzLmxlbmd0aCAlIDIgPT09IDEpIHtcbiAgICAgICAgcmVzLnVuc2hpZnQoJzAnKTtcbiAgICB9XG4gICAgbGV0IGhleExlYWRpbmdaZXJvcyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJlc1tpXSAhPT0gJzAnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhleExlYWRpbmdaZXJvcysrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcyA9IHJlcy5zbGljZShoZXhMZWFkaW5nWmVyb3MgLSAoaGV4TGVhZGluZ1plcm9zICUgMikpO1xuICAgIGxldCBoZXhTdHIgPSByZXMuam9pbignJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1MZWFkaW5nWmVyb0J5dGVzOyBpKyspIHtcbiAgICAgICAgaGV4U3RyID0gYDAwJHtoZXhTdHJ9YDtcbiAgICB9XG4gICAgaWYgKG1pbkxlbmd0aCkge1xuICAgICAgICBjb25zdCBjb3VudCA9IG1pbkxlbmd0aCAqIDIgLSBoZXhTdHIubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpICs9IDIpIHtcbiAgICAgICAgICAgIGhleFN0ciA9IGAwMCR7aGV4U3RyfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhleFN0cjtcbn1cbmV4cG9ydHMuYzMyZGVjb2RlID0gYzMyZGVjb2RlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/c32check/lib/encoding.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/c32check/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/c32check/lib/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.b58ToC32 = exports.c32ToB58 = exports.versions = exports.c32normalize = exports.c32addressDecode = exports.c32address = exports.c32checkDecode = exports.c32checkEncode = exports.c32decode = exports.c32encode = void 0;\nconst encoding_1 = __webpack_require__(/*! ./encoding */ \"(ssr)/./node_modules/c32check/lib/encoding.js\");\nObject.defineProperty(exports, \"c32encode\", ({ enumerable: true, get: function () { return encoding_1.c32encode; } }));\nObject.defineProperty(exports, \"c32decode\", ({ enumerable: true, get: function () { return encoding_1.c32decode; } }));\nObject.defineProperty(exports, \"c32normalize\", ({ enumerable: true, get: function () { return encoding_1.c32normalize; } }));\nconst checksum_1 = __webpack_require__(/*! ./checksum */ \"(ssr)/./node_modules/c32check/lib/checksum.js\");\nObject.defineProperty(exports, \"c32checkEncode\", ({ enumerable: true, get: function () { return checksum_1.c32checkEncode; } }));\nObject.defineProperty(exports, \"c32checkDecode\", ({ enumerable: true, get: function () { return checksum_1.c32checkDecode; } }));\nconst address_1 = __webpack_require__(/*! ./address */ \"(ssr)/./node_modules/c32check/lib/address.js\");\nObject.defineProperty(exports, \"c32address\", ({ enumerable: true, get: function () { return address_1.c32address; } }));\nObject.defineProperty(exports, \"c32addressDecode\", ({ enumerable: true, get: function () { return address_1.c32addressDecode; } }));\nObject.defineProperty(exports, \"c32ToB58\", ({ enumerable: true, get: function () { return address_1.c32ToB58; } }));\nObject.defineProperty(exports, \"b58ToC32\", ({ enumerable: true, get: function () { return address_1.b58ToC32; } }));\nObject.defineProperty(exports, \"versions\", ({ enumerable: true, get: function () { return address_1.versions; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYzMyY2hlY2svbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLG9CQUFvQixHQUFHLHdCQUF3QixHQUFHLGtCQUFrQixHQUFHLHNCQUFzQixHQUFHLHNCQUFzQixHQUFHLGlCQUFpQixHQUFHLGlCQUFpQjtBQUN2TixtQkFBbUIsbUJBQU8sQ0FBQyxpRUFBWTtBQUN2Qyw2Q0FBNEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDcEgsNkNBQTRDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ3BILGdEQUErQyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUMxSCxtQkFBbUIsbUJBQU8sQ0FBQyxpRUFBWTtBQUN2QyxrREFBaUQsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDOUgsa0RBQWlELEVBQUUscUNBQXFDLHFDQUFxQyxFQUFDO0FBQzlILGtCQUFrQixtQkFBTyxDQUFDLCtEQUFXO0FBQ3JDLDhDQUE2QyxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUNySCxvREFBbUQsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDakksNENBQTJDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ2pILDRDQUEyQyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNqSCw0Q0FBMkMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNib29rL1NJUF9JbXBsL25mdC1mcm9udGVuZC9ub2RlX21vZHVsZXMvYzMyY2hlY2svbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5iNThUb0MzMiA9IGV4cG9ydHMuYzMyVG9CNTggPSBleHBvcnRzLnZlcnNpb25zID0gZXhwb3J0cy5jMzJub3JtYWxpemUgPSBleHBvcnRzLmMzMmFkZHJlc3NEZWNvZGUgPSBleHBvcnRzLmMzMmFkZHJlc3MgPSBleHBvcnRzLmMzMmNoZWNrRGVjb2RlID0gZXhwb3J0cy5jMzJjaGVja0VuY29kZSA9IGV4cG9ydHMuYzMyZGVjb2RlID0gZXhwb3J0cy5jMzJlbmNvZGUgPSB2b2lkIDA7XG5jb25zdCBlbmNvZGluZ18xID0gcmVxdWlyZShcIi4vZW5jb2RpbmdcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjMzJlbmNvZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kaW5nXzEuYzMyZW5jb2RlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYzMyZGVjb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmNvZGluZ18xLmMzMmRlY29kZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImMzMm5vcm1hbGl6ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RpbmdfMS5jMzJub3JtYWxpemU7IH0gfSk7XG5jb25zdCBjaGVja3N1bV8xID0gcmVxdWlyZShcIi4vY2hlY2tzdW1cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjMzJjaGVja0VuY29kZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2hlY2tzdW1fMS5jMzJjaGVja0VuY29kZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImMzMmNoZWNrRGVjb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjaGVja3N1bV8xLmMzMmNoZWNrRGVjb2RlOyB9IH0pO1xuY29uc3QgYWRkcmVzc18xID0gcmVxdWlyZShcIi4vYWRkcmVzc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImMzMmFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkZHJlc3NfMS5jMzJhZGRyZXNzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYzMyYWRkcmVzc0RlY29kZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWRkcmVzc18xLmMzMmFkZHJlc3NEZWNvZGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjMzJUb0I1OFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWRkcmVzc18xLmMzMlRvQjU4OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYjU4VG9DMzJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkZHJlc3NfMS5iNThUb0MzMjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZlcnNpb25zXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhZGRyZXNzXzEudmVyc2lvbnM7IH0gfSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/c32check/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/c32check/node_modules/base-x/src/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/c32check/node_modules/base-x/src/index.js ***!
  \****************************************************************/
/***/ ((module) => {

eval("\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) {\n    } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Find code of next character\n      var charCode = source.charCodeAt(psz)\n            // Base map can not be indexed using char code\n      if (charCode > 255) { return }\n            // Decode character\n      var carry = BASE_MAP[charCode]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = new Uint8Array(zeroes + (size - it4))\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYzMyY2hlY2svbm9kZV9tb2R1bGVzL2Jhc2UteC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDZDQUE2QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWSxTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsK0JBQStCLDZDQUE2QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21hY2Jvb2svU0lQX0ltcGwvbmZ0LWZyb250ZW5kL25vZGVfbW9kdWxlcy9jMzJjaGVjay9ub2RlX21vZHVsZXMvYmFzZS14L3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbi8vIGJhc2UteCBlbmNvZGluZyAvIGRlY29kaW5nXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTggYmFzZS14IGNvbnRyaWJ1dG9yc1xuLy8gQ29weXJpZ2h0IChjKSAyMDE0LTIwMTggVGhlIEJpdGNvaW4gQ29yZSBkZXZlbG9wZXJzIChiYXNlNTguY3BwKVxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBzb2Z0d2FyZSBsaWNlbnNlLCBzZWUgdGhlIGFjY29tcGFueWluZ1xuLy8gZmlsZSBMSUNFTlNFIG9yIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwLlxuZnVuY3Rpb24gYmFzZSAoQUxQSEFCRVQpIHtcbiAgaWYgKEFMUEhBQkVULmxlbmd0aCA+PSAyNTUpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxwaGFiZXQgdG9vIGxvbmcnKSB9XG4gIHZhciBCQVNFX01BUCA9IG5ldyBVaW50OEFycmF5KDI1NilcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBCQVNFX01BUC5sZW5ndGg7IGorKykge1xuICAgIEJBU0VfTUFQW2pdID0gMjU1XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBBTFBIQUJFVC5sZW5ndGg7IGkrKykge1xuICAgIHZhciB4ID0gQUxQSEFCRVQuY2hhckF0KGkpXG4gICAgdmFyIHhjID0geC5jaGFyQ29kZUF0KDApXG4gICAgaWYgKEJBU0VfTUFQW3hjXSAhPT0gMjU1KSB7IHRocm93IG5ldyBUeXBlRXJyb3IoeCArICcgaXMgYW1iaWd1b3VzJykgfVxuICAgIEJBU0VfTUFQW3hjXSA9IGlcbiAgfVxuICB2YXIgQkFTRSA9IEFMUEhBQkVULmxlbmd0aFxuICB2YXIgTEVBREVSID0gQUxQSEFCRVQuY2hhckF0KDApXG4gIHZhciBGQUNUT1IgPSBNYXRoLmxvZyhCQVNFKSAvIE1hdGgubG9nKDI1NikgLy8gbG9nKEJBU0UpIC8gbG9nKDI1NiksIHJvdW5kZWQgdXBcbiAgdmFyIGlGQUNUT1IgPSBNYXRoLmxvZygyNTYpIC8gTWF0aC5sb2coQkFTRSkgLy8gbG9nKDI1NikgLyBsb2coQkFTRSksIHJvdW5kZWQgdXBcbiAgZnVuY3Rpb24gZW5jb2RlIChzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHNvdXJjZSkpIHtcbiAgICAgIHNvdXJjZSA9IG5ldyBVaW50OEFycmF5KHNvdXJjZS5idWZmZXIsIHNvdXJjZS5ieXRlT2Zmc2V0LCBzb3VyY2UuYnl0ZUxlbmd0aClcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgc291cmNlID0gVWludDhBcnJheS5mcm9tKHNvdXJjZSlcbiAgICB9XG4gICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpIH1cbiAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gJycgfVxuICAgICAgICAvLyBTa2lwICYgY291bnQgbGVhZGluZyB6ZXJvZXMuXG4gICAgdmFyIHplcm9lcyA9IDBcbiAgICB2YXIgbGVuZ3RoID0gMFxuICAgIHZhciBwYmVnaW4gPSAwXG4gICAgdmFyIHBlbmQgPSBzb3VyY2UubGVuZ3RoXG4gICAgd2hpbGUgKHBiZWdpbiAhPT0gcGVuZCAmJiBzb3VyY2VbcGJlZ2luXSA9PT0gMCkge1xuICAgICAgcGJlZ2luKytcbiAgICAgIHplcm9lcysrXG4gICAgfVxuICAgICAgICAvLyBBbGxvY2F0ZSBlbm91Z2ggc3BhY2UgaW4gYmlnLWVuZGlhbiBiYXNlNTggcmVwcmVzZW50YXRpb24uXG4gICAgdmFyIHNpemUgPSAoKHBlbmQgLSBwYmVnaW4pICogaUZBQ1RPUiArIDEpID4+PiAwXG4gICAgdmFyIGI1OCA9IG5ldyBVaW50OEFycmF5KHNpemUpXG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIGJ5dGVzLlxuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQpIHtcbiAgICAgIHZhciBjYXJyeSA9IHNvdXJjZVtwYmVnaW5dXG4gICAgICAgICAgICAvLyBBcHBseSBcImI1OCA9IGI1OCAqIDI1NiArIGNoXCIuXG4gICAgICB2YXIgaSA9IDBcbiAgICAgIGZvciAodmFyIGl0MSA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgKGl0MSAhPT0gLTEpOyBpdDEtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9ICgyNTYgKiBiNThbaXQxXSkgPj4+IDBcbiAgICAgICAgYjU4W2l0MV0gPSAoY2FycnkgJSBCQVNFKSA+Pj4gMFxuICAgICAgICBjYXJyeSA9IChjYXJyeSAvIEJBU0UpID4+PiAwXG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdOb24temVybyBjYXJyeScpIH1cbiAgICAgIGxlbmd0aCA9IGlcbiAgICAgIHBiZWdpbisrXG4gICAgfVxuICAgICAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzIGluIGJhc2U1OCByZXN1bHQuXG4gICAgdmFyIGl0MiA9IHNpemUgLSBsZW5ndGhcbiAgICB3aGlsZSAoaXQyICE9PSBzaXplICYmIGI1OFtpdDJdID09PSAwKSB7XG4gICAgICBpdDIrK1xuICAgIH1cbiAgICAgICAgLy8gVHJhbnNsYXRlIHRoZSByZXN1bHQgaW50byBhIHN0cmluZy5cbiAgICB2YXIgc3RyID0gTEVBREVSLnJlcGVhdCh6ZXJvZXMpXG4gICAgZm9yICg7IGl0MiA8IHNpemU7ICsraXQyKSB7IHN0ciArPSBBTFBIQUJFVC5jaGFyQXQoYjU4W2l0Ml0pIH1cbiAgICByZXR1cm4gc3RyXG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlVW5zYWZlIChzb3VyY2UpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgU3RyaW5nJykgfVxuICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7IHJldHVybiBuZXcgVWludDhBcnJheSgpIH1cbiAgICB2YXIgcHN6ID0gMFxuICAgICAgICAvLyBTa2lwIGFuZCBjb3VudCBsZWFkaW5nICcxJ3MuXG4gICAgdmFyIHplcm9lcyA9IDBcbiAgICB2YXIgbGVuZ3RoID0gMFxuICAgIHdoaWxlIChzb3VyY2VbcHN6XSA9PT0gTEVBREVSKSB7XG4gICAgICB6ZXJvZXMrK1xuICAgICAgcHN6KytcbiAgICB9XG4gICAgICAgIC8vIEFsbG9jYXRlIGVub3VnaCBzcGFjZSBpbiBiaWctZW5kaWFuIGJhc2UyNTYgcmVwcmVzZW50YXRpb24uXG4gICAgdmFyIHNpemUgPSAoKChzb3VyY2UubGVuZ3RoIC0gcHN6KSAqIEZBQ1RPUikgKyAxKSA+Pj4gMCAvLyBsb2coNTgpIC8gbG9nKDI1NiksIHJvdW5kZWQgdXAuXG4gICAgdmFyIGIyNTYgPSBuZXcgVWludDhBcnJheShzaXplKVxuICAgICAgICAvLyBQcm9jZXNzIHRoZSBjaGFyYWN0ZXJzLlxuICAgIHdoaWxlIChzb3VyY2VbcHN6XSkge1xuICAgICAgICAgICAgLy8gRmluZCBjb2RlIG9mIG5leHQgY2hhcmFjdGVyXG4gICAgICB2YXIgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwc3opXG4gICAgICAgICAgICAvLyBCYXNlIG1hcCBjYW4gbm90IGJlIGluZGV4ZWQgdXNpbmcgY2hhciBjb2RlXG4gICAgICBpZiAoY2hhckNvZGUgPiAyNTUpIHsgcmV0dXJuIH1cbiAgICAgICAgICAgIC8vIERlY29kZSBjaGFyYWN0ZXJcbiAgICAgIHZhciBjYXJyeSA9IEJBU0VfTUFQW2NoYXJDb2RlXVxuICAgICAgICAgICAgLy8gSW52YWxpZCBjaGFyYWN0ZXJcbiAgICAgIGlmIChjYXJyeSA9PT0gMjU1KSB7IHJldHVybiB9XG4gICAgICB2YXIgaSA9IDBcbiAgICAgIGZvciAodmFyIGl0MyA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgKGl0MyAhPT0gLTEpOyBpdDMtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9IChCQVNFICogYjI1NltpdDNdKSA+Pj4gMFxuICAgICAgICBiMjU2W2l0M10gPSAoY2FycnkgJSAyNTYpID4+PiAwXG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gMjU2KSA+Pj4gMFxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKSB9XG4gICAgICBsZW5ndGggPSBpXG4gICAgICBwc3orK1xuICAgIH1cbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lcyBpbiBiMjU2LlxuICAgIHZhciBpdDQgPSBzaXplIC0gbGVuZ3RoXG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSAmJiBiMjU2W2l0NF0gPT09IDApIHtcbiAgICAgIGl0NCsrXG4gICAgfVxuICAgIHZhciB2Y2ggPSBuZXcgVWludDhBcnJheSh6ZXJvZXMgKyAoc2l6ZSAtIGl0NCkpXG4gICAgdmFyIGogPSB6ZXJvZXNcbiAgICB3aGlsZSAoaXQ0ICE9PSBzaXplKSB7XG4gICAgICB2Y2hbaisrXSA9IGIyNTZbaXQ0KytdXG4gICAgfVxuICAgIHJldHVybiB2Y2hcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGUgKHN0cmluZykge1xuICAgIHZhciBidWZmZXIgPSBkZWNvZGVVbnNhZmUoc3RyaW5nKVxuICAgIGlmIChidWZmZXIpIHsgcmV0dXJuIGJ1ZmZlciB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24tYmFzZScgKyBCQVNFICsgJyBjaGFyYWN0ZXInKVxuICB9XG4gIHJldHVybiB7XG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgZGVjb2RlVW5zYWZlOiBkZWNvZGVVbnNhZmUsXG4gICAgZGVjb2RlOiBkZWNvZGVcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBiYXNlXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/c32check/node_modules/base-x/src/index.js\n");

/***/ })

};
;